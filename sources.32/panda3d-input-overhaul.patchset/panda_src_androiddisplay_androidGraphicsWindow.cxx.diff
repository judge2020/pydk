--- panda3d-input-overhaul/panda/src/androiddisplay/androidGraphicsWindow.cxx	2018-02-04 11:37:09.000000000 +0100
+++ panda3d-input-overhaul.api19/panda/src/androiddisplay/androidGraphicsWindow.cxx	2018-03-08 04:47:00.691237605 +0100
@@ -8,7 +8,7 @@
  *
  * @file androidGraphicsWindow.cxx
  * @author rdb
- * @date 2013-01-11
+ * @date 20173-01-11 modified for android activity pmp-p
  */
 
 #include "androidGraphicsWindow.h"
@@ -26,9 +26,19 @@
 #include "nativeWindowHandle.h"
 
 #include "android_native_app_glue.h"
-#include <android/window.h>
+//#include <android/window.h>
 #include <android/log.h>
 
+
+//#include <jni.h>
+#include <stdlib.h>
+
+#define LOG_TAG "androidGraphicsWindow.cxx"
+#define LOG_INFO(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
+#define LOG_ERROR(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
+
+static EGLNativeWindowType awindow = NULL;
+
 extern IMPORT_CLASS struct android_app* panda_android_app;
 
 TypeHandle AndroidGraphicsWindow::_type_handle;
@@ -47,17 +57,30 @@
   GraphicsWindow(engine, pipe, name, fb_prop, win_prop, flags, gsg, host),
   _mouse_button_state(0)
 {
-  AndroidGraphicsPipe *android_pipe;
-  DCAST_INTO_V(android_pipe, _pipe);
+    AndroidGraphicsPipe *android_pipe;
+    DCAST_INTO_V(android_pipe, _pipe);
 
-  _egl_display = android_pipe->_egl_display;
-  _egl_surface = 0;
+    _egl_display = android_pipe->_egl_display;
+    _egl_surface = 0;
 
-  _app = panda_android_app;
+    _app = panda_android_app;
 
-  GraphicsWindowInputDevice device =
-    GraphicsWindowInputDevice::pointer_and_keyboard(this, "keyboard_mouse");
-  add_input_device(device);
+#ifdef OPENGLES_2
+    LOG_INFO("                                     ===== GL ES 2.0 ============");
+    LOG_INFO("GLSL: %s", (char *) glGetString(GL_SHADING_LANGUAGE_VERSION) );
+    printf("GL_SHADING_LANGUAGE_VERSION: %s\n", (char *) glGetString(GL_SHADING_LANGUAGE_VERSION));
+
+#else
+    #ifdef OPENGLES_1
+        LOG_INFO("                                 ===== GL ES 1.0 : NO LUI====");
+    #else
+        #error OPENGLES_1/2 must be defined
+    #endif
+#endif
+
+    PT(GraphicsWindowInputDevice) device = GraphicsWindowInputDevice::pointer_and_keyboard(this, "keyboard_mouse");
+
+    add_input_device(device);
 }
 
 /**
@@ -65,7 +88,8 @@
  */
 AndroidGraphicsWindow::
 ~AndroidGraphicsWindow() {
-  destroy_surface();
+    LOG_ERROR("~AndroidGraphicsWindow() should not destroy_surface");
+    destroy_surface();
 }
 
 /**
@@ -88,6 +112,7 @@
     return false;
   }
 
+
   AndroidGraphicsStateGuardian *androidgsg;
   DCAST_INTO_R(androidgsg, _gsg, false);
   {
@@ -179,6 +204,9 @@
 process_events() {
   GraphicsWindow::process_events();
 
+#if defined(__ANDROID_API__) && __ANDROID_API__ < 20
+    #warning fixme process_events
+#else
   // Read all pending events.
   int looper_id;
   int events;
@@ -191,6 +219,8 @@
       source->process(_app, source);
     }
   }
+#endif
+
 }
 
 /**
@@ -207,32 +237,37 @@
  */
 void AndroidGraphicsWindow::
 set_properties_now(WindowProperties &properties) {
-  if (_pipe == (GraphicsPipe *)NULL) {
-    // If the pipe is null, we're probably closing down.
-    GraphicsWindow::set_properties_now(properties);
-    return;
-  }
+    if (_pipe == (GraphicsPipe *)NULL) {
+        // If the pipe is null, we're probably closing down.
+        GraphicsWindow::set_properties_now(properties);
+        return;
+    }
 
-  GraphicsWindow::set_properties_now(properties);
-  if (!properties.is_any_specified()) {
-    // The base class has already handled this case.
-    return;
-  }
+    GraphicsWindow::set_properties_now(properties);
 
-  // There's not really much we can change on Android.
-  if (properties.has_fullscreen()) {
-    uint32_t add_flags = 0;
-    uint32_t del_flags = 0;
-    if (_properties.get_fullscreen()) {
-      add_flags |= AWINDOW_FLAG_FULLSCREEN;
-    } else {
-      del_flags |= AWINDOW_FLAG_FULLSCREEN;
+    if (!properties.is_any_specified()) {
+        // The base class has already handled this case.
+        return;
     }
-    ANativeActivity_setWindowFlags(_app->activity, add_flags, del_flags);
 
-    _properties.set_fullscreen(properties.get_fullscreen());
-    properties.clear_fullscreen();
-  }
+    // There's not really much we can change on Android.
+    if (properties.has_fullscreen()) {
+        //uint32_t add_flags = 0;
+        //uint32_t del_flags = 0;
+        if (_properties.get_fullscreen()) {
+            LOG_INFO("AWINDOW_FLAG_FULLSCREEN => #t");
+            setenv("PAPI_FS","#t",1);
+        } else {
+            LOG_INFO("AWINDOW_FLAG_FULLSCREEN => #f");
+            setenv("PAPI_FS","#f",1);
+        }
+
+        //ANativeActivity_setWindowFlags(_app->activity, add_flags, del_flags);
+
+        _properties.set_fullscreen(properties.get_fullscreen());
+        properties.clear_fullscreen();
+
+    }
 }
 
 /**
@@ -240,6 +275,11 @@
  */
 void AndroidGraphicsWindow::
 close_window() {
+
+
+#if defined(__ANDROID_API__) && __ANDROID_API__ < 20
+    #warning fixme close_window
+#else
   destroy_surface();
 
   if (_gsg != (GraphicsStateGuardian *)NULL) {
@@ -254,6 +294,7 @@
     _app->onAppCmd = nullptr;
     _app->onInputEvent = nullptr;
   }
+#endif
 }
 
 /**
@@ -280,6 +321,23 @@
     }
   }
 
+#if defined(__ANDROID_API__) && __ANDROID_API__ < 20
+    char* senv;
+    senv= getenv("PANDA_NATIVE_WINDOW");
+    sscanf( senv, "%p", &awindow );
+    LOG_INFO(" >>>>> window pointer %p found <<<<< ", awindow);
+
+    senv= getenv("PANDA_NATIVE_SURFACE");
+    sscanf( senv, "%p", &_egl_surface );
+    LOG_INFO(" >>>>> surface pointer %p found <<<<< ", _egl_surface);
+
+    if (_egl_surface == EGL_NO_SURFACE) {
+        androiddisplay_cat.error() << "NO EGL Surface pointer\n";
+        return false;
+    }
+    _properties.set_origin(100, -100);
+    _properties.set_undecorated(true);
+#else
   // Register the callbacks
   assert(_app != NULL);
   _app->userData = this;
@@ -296,10 +354,11 @@
     return false;
   }
 
-  // Set some other properties.
+    // Set some other properties.
   _properties.set_origin(0, 0);
   _properties.set_cursor_hidden(true);
   _properties.set_undecorated(true);
+#endif
 
   if (!androidgsg->get_fb_properties().verify_hardware_software
       (_fb_properties, androidgsg->get_gl_renderer())) {
@@ -311,6 +370,8 @@
 
   androiddisplay_cat.error() << "open_window done\n";
 
+  create_surface();
+
   return true;
 }
 
@@ -319,6 +380,11 @@
  */
 void AndroidGraphicsWindow::
 destroy_surface() {
+
+#if defined(__ANDROID_API__) && __ANDROID_API__ < 20
+    #warning fixme
+    _egl_surface = EGL_NO_SURFACE;
+#else
   if (_egl_surface != EGL_NO_SURFACE) {
     if (!eglDestroySurface(_egl_display, _egl_surface)) {
       androiddisplay_cat.error() << "Failed to destroy surface: "
@@ -326,6 +392,7 @@
     }
     _egl_surface = EGL_NO_SURFACE;
   }
+#endif
 
   // Destroy the current context.
   if (_gsg != (GraphicsStateGuardian *)NULL) {
@@ -340,6 +407,46 @@
  */
 bool AndroidGraphicsWindow::
 create_surface() {
+#if defined(__ANDROID_API__) && __ANDROID_API__ < 20
+    LOG_INFO("362: create_surface");
+
+    #ifdef OPENGLES_2
+        LOG_INFO(" u.r    ===== GL ES 2.0 ============");
+    #else
+        #ifdef OPENGLES_1
+            LOG_INFO(" u.r    ===== GL ES 1.0 : NO LUI====");
+        #else
+            #error OPENGLES_1/2 must be defined
+        #endif
+    #endif
+
+    AndroidGraphicsStateGuardian *androidgsg;
+    DCAST_INTO_R(androidgsg, _gsg, false);
+
+/*
+    ANativeWindow_setBuffersGeometry(awindow, 0, 0, androidgsg->_format);
+  // Create the EGL surface.
+  _egl_surface = eglCreateWindowSurface(_egl_display, androidgsg->_fbconfig, awindow, NULL);
+  if (eglGetError() != EGL_SUCCESS) {
+    androiddisplay_cat.error()
+      << "Failed to create window surface.\n";
+    return false;
+  }
+*/
+    char* senv;
+    EGLContext context = EGL_NO_CONTEXT;
+    senv= getenv("PANDA_NATIVE_CONTEXT");
+    sscanf( senv, "%p", &context );
+    LOG_INFO(" >>>>> context pointer %p found <<<<< ", context);
+
+    androidgsg->_context = context;
+
+    // Switch to our newly created context.
+    if (!eglMakeCurrent(_egl_display, _egl_surface, _egl_surface, androidgsg->_context)) {
+        androiddisplay_cat.error() << "Failed to call eglMakeCurrent: " << get_egl_error_string(eglGetError()) << "\n";
+    }
+
+#else
   AndroidGraphicsStateGuardian *androidgsg;
   DCAST_INTO_R(androidgsg, _gsg, false);
 
@@ -387,7 +494,7 @@
     close_window();
     return false;
   }
-
+#endif
   return true;
 }
 
@@ -406,7 +513,9 @@
 void AndroidGraphicsWindow::
 ns_handle_command(int32_t command) {
   WindowProperties properties;
-
+#if defined(__ANDROID_API__) && __ANDROID_API__ < 20
+    #warning fixme
+#else
   switch (command) {
     case APP_CMD_SAVE_STATE:
       // The system has asked us to save our current state.  Do so.
@@ -435,15 +544,13 @@
       system_changed_properties(properties);
       break;
     case APP_CMD_WINDOW_RESIZED:
-      properties.set_size(ANativeWindow_getWidth(_app->window),
-                          ANativeWindow_getHeight(_app->window));
+      properties.set_size(ANativeWindow_getWidth(_app->window), ANativeWindow_getHeight(_app->window));
       break;
     case APP_CMD_WINDOW_REDRAW_NEEDED:
       break;
     case APP_CMD_CONTENT_RECT_CHANGED:
       properties.set_origin(_app->contentRect.left, _app->contentRect.top);
-      properties.set_size(_app->contentRect.right - _app->contentRect.left,
-                          _app->contentRect.bottom - _app->contentRect.top);
+      properties.set_size(_app->contentRect.right - _app->contentRect.left,  _app->contentRect.bottom - _app->contentRect.top);
       system_changed_properties(properties);
       break;
     case APP_CMD_GAINED_FOCUS:
@@ -460,6 +567,7 @@
       system_changed_properties(properties);
       break;
   }
+#endif
 }
 
 /**
@@ -467,8 +575,10 @@
  */
 int32_t AndroidGraphicsWindow::
 handle_input_event(struct android_app* app, AInputEvent *event) {
+#if defined(__ANDROID_API__) && __ANDROID_API__ < 20
+    #warning fixme
+#else
   AndroidGraphicsWindow* window = (AndroidGraphicsWindow*) app->userData;
-
   int32_t event_type = AInputEvent_getType(event);
   switch (event_type) {
   case AINPUT_EVENT_TYPE_KEY:
@@ -476,6 +586,7 @@
   case AINPUT_EVENT_TYPE_MOTION:
     return window->handle_motion_event(event);
   }
+#endif
   return 0;
 }
 
@@ -505,12 +616,14 @@
     _input_devices[0].button_down(KeyboardButton.rshift());
   }*/
 
+#if defined(__ANDROID_API__) && __ANDROID_API__ < 20
+    #warning FIXME
+#else
   int32_t keycode = AKeyEvent_getKeyCode(event);
   ButtonHandle button = map_button(keycode);
 
   if (button == ButtonHandle::none()) {
-    androiddisplay_cat.warning()
-      << "Unknown keycode: " << keycode << "\n";
+    androiddisplay_cat.warning() << "Unknown keycode: " << keycode << "\n";
     return 0;
   }
 
@@ -521,6 +634,7 @@
   } else if (action == AKEY_EVENT_ACTION_UP) {
     _input_devices[0].button_up(button);
   }
+#endif
   // TODO getRepeatCount, ACTION_MULTIPLE
 
   return 1;
@@ -531,6 +645,11 @@
  */
 int32_t AndroidGraphicsWindow::
 handle_motion_event(const AInputEvent *event) {
+
+#if defined(__ANDROID_API__) && __ANDROID_API__ < 20
+    #warning FIXME
+#else
+
   int32_t action = AMotionEvent_getAction(event);
   action &= AMOTION_EVENT_ACTION_MASK;
 
@@ -563,7 +682,7 @@
   float y = AMotionEvent_getY(event, 0) - _app->contentRect.top;
 
   _input_devices[0].set_pointer_in_window(x, y);
-
+#endif
   return 1;
 }
 
